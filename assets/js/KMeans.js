// Generated by CoffeeScript 1.6.3
var Cluster, DataPoint, KMeans;

KMeans = (function() {
  function KMeans(numClusters, numDimensions) {
    var i;
    this.numClusters = numClusters;
    this.clusters = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= numClusters ? _i < numClusters : _i > numClusters; i = 0 <= numClusters ? ++_i : --_i) {
        _results.push(new Cluster(numDimensions));
      }
      return _results;
    })();
  }

  KMeans.prototype.setPoints = function(points) {
    var data, weight;
    return this.dataPoints = (function() {
      var _i, _len, _ref, _results;
      _results = [];
      for (_i = 0, _len = points.length; _i < _len; _i++) {
        _ref = points[_i], data = _ref[0], weight = _ref[1];
        _results.push(new DataPoint(data, weight));
      }
      return _results;
    })();
  };

  KMeans.prototype.performCluster = function() {
    var movesMade;
    this.initClusters();
    while (true) {
      movesMade = this.clusterStep();
      if (movesMade === 0) {
        break;
      }
    }
    return this.clusters;
  };

  KMeans.prototype.initClusters = function() {
    var bestCenter, cluster, firstCenterIndex, maxDist, minDist, numPoints, point, _i, _j, _len, _len1, _ref, _ref1, _results;
    numPoints = this.dataPoints.length;
    firstCenterIndex = Math.floor(Math.random() * numPoints);
    this.clusters[0].addPoint(this.dataPoints[firstCenterIndex]);
    _ref = this.clusters.slice(1);
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      cluster = _ref[_i];
      maxDist = 0;
      bestCenter = null;
      _ref1 = this.dataPoints;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        point = _ref1[_j];
        if (point.cluster == null) {
          minDist = this.nearestClusterDistance(point);
          if (minDist > maxDist) {
            maxDist = minDist;
            bestCenter = point;
          }
        }
      }
      _results.push(cluster.addPoint(bestCenter));
    }
    return _results;
  };

  KMeans.prototype.nearestClusterDistance = function(point) {
    var cluster, minDist, _i, _len, _ref;
    minDist = Number.POSITIVE_INFINITY;
    _ref = this.clusters;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      cluster = _ref[_i];
      if ((cluster != null) && cluster.size > 0) {
        minDist = Math.min(minDist, cluster.getDistanceTo(point));
      }
    }
    return minDist;
  };

  KMeans.prototype.nearestClusterTo = function(point) {
    var cluster, distance, nearestCluster, nearestDistance, _i, _len, _ref;
    nearestCluster = null;
    nearestDistance = Number.POSITIVE_INFINITY;
    _ref = this.clusters;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      cluster = _ref[_i];
      if ((cluster != null) && cluster.size > 0) {
        if (nearestCluster == null) {
          nearestCluster = cluster;
          nearestDistance = nearestCluster.getDistanceTo(point);
        } else {
          distance = cluster.getDistanceTo(point);
          if (distance < nearestDistance) {
            nearestCluster = cluster;
            nearestDistance = distance;
          }
        }
      }
    }
    return nearestCluster;
  };

  KMeans.prototype.reassignPoint = function(point, cluster) {
    var currentCluster, wasAbleToAssign;
    currentCluster = point.cluster;
    wasAbleToAssign = false;
    if (currentCluster == null) {
      cluster.addPoint(point);
      wasAbleToAssign = true;
    } else if (currentCluster.size > 1 && cluster !== currentCluster) {
      currentCluster.removePoint(point);
      cluster.addPoint(point);
      wasAbleToAssign = true;
    }
    return wasAbleToAssign;
  };

  KMeans.prototype.clusterStep = function() {
    var nearestCluster, numMoves, point, _i, _len, _ref;
    numMoves = 0;
    _ref = this.dataPoints;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      point = _ref[_i];
      nearestCluster = this.nearestClusterTo(point);
      if (this.reassignPoint(point, nearestCluster)) {
        numMoves++;
      }
    }
    return numMoves;
  };

  return KMeans;

})();

DataPoint = (function() {
  function DataPoint(data, weight, cluster) {
    this.data = data;
    this.weight = weight != null ? weight : 1;
    this.cluster = cluster != null ? cluster : null;
  }

  return DataPoint;

})();

Cluster = (function() {
  function Cluster(numDimensions) {
    var i, _i, _results;
    this.size = 0;
    this.dimensions = (function() {
      _results = [];
      for (var _i = 0; 0 <= numDimensions ? _i < numDimensions : _i > numDimensions; 0 <= numDimensions ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this);
    this.sum = (function() {
      var _j, _len, _ref, _results1;
      _ref = this.dimensions;
      _results1 = [];
      for (_j = 0, _len = _ref.length; _j < _len; _j++) {
        i = _ref[_j];
        _results1.push(0);
      }
      return _results1;
    }).call(this);
  }

  Cluster.prototype.addPoint = function(point) {
    var i, _i, _len, _ref;
    this.size += point.weight;
    _ref = this.dimensions;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      i = _ref[_i];
      this.sum[i] += point.data[i] * point.weight;
    }
    return point.cluster = this;
  };

  Cluster.prototype.removePoint = function(point) {
    var i, _i, _len, _ref, _results;
    point.cluster = null;
    this.size -= point.weight;
    _ref = this.dimensions;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      i = _ref[_i];
      _results.push(this.sum[i] -= point.data[i] * point.weight);
    }
    return _results;
  };

  Cluster.prototype.getMean = function() {
    var i, _i, _len, _ref, _results;
    _ref = this.dimensions;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      i = _ref[_i];
      _results.push(this.sum[i] / this.size);
    }
    return _results;
  };

  Cluster.prototype.getDistanceTo = function(point) {
    var centroid, diff, i, squaredDist, _i, _len, _ref;
    centroid = this.getMean();
    squaredDist = 0;
    _ref = this.dimensions;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      i = _ref[_i];
      diff = centroid[i] - point.data[i];
      squaredDist += diff * diff;
    }
    return squaredDist;
  };

  return Cluster;

})();
